# $HOME

Welcome to my $HOME.
See my desktop [in action](https://user-images.githubusercontent.com/63266536/108628904-10951e80-743c-11eb-9628-b502ee6e02c7.mp4).

Some relevant scripts, dotfiles, and theme stuff I use is here.
Most scripts I use, however are in other repositories here in Github.
You can find more stuff in the following repositories:

* [shod](https://github.com/phillbush/shod): The shod window manager.
* [lsd](https://github.com/phillbush/lsd) and
  [lsc](https://github.com/phillbush/lsc): List desktop/client, useful in scripts.
* [focus](https://github.com/phillbush/focus): Change focus.
* [fmutils](https://github.com/phillbush/fmutils): File management scripts.
* [xutils](https://github.com/phillbush/xutils): X11 scripts.
* [wrappers](https://github.com/phillbush/wrappers): Misc scripts.
* [pmenu](https://github.com/phillbush/pmenu): Pie menu.
* [xprompt](https://github.com/phillbush/xprompt): X11 prompt.

Except for the content in the `./theme/` directory,
everything in this repo was created by me and is in public domain.
I use the following themes:

* The [retrosmart](https://github.com/mdomlop/retrosmart-x11-cursors)
  cursor theme, licensed under the
  [GPLv3 license](https://github.com/mdomlop/retrosmart-x11-cursors/blob/master/LICENSE).
* The [ubo](http://pen-art.ru/icons-ubo-ru.html)
  icon theme, licensed under the Artistic 2.0 license.
* The [Input](https://input.fontbureau.com/)
  font, which has a [license](https://input.fontbureau.com/license/) that does
  not permit redistribution.  So I cannot distribute the font here.

## Directory Structure

The contents of my $HOME are listed below.
Note that I do not use the XDG home structure.

* `~/.profile`:
  Shell script that sets the environment variables necessary to set up a user session.

* `~/.session`:
  Shell script called by ksh(1) to set up a shell session
  (prompt, aliases, etc).

* `~/.xsession`:
  Shell script called by xenodm(1) to set up a X session
  (notification system, window manager, etc).

* `~/files/`:
  Where I archive documents, media, and files for consumption.
  Each category of files has a subdirectory in it.
  For example, `~/files/doc/` for non-fiction books;
  `~/files/lit/` for fiction books;
  `~/files/meme/` is the meme folder;
  `~/files/mus/` is the music folder; etc.

* `~/proj/`:
  Where I put whatever I am working on
  (mostly college stuff, things I am learning, and programs I maintain).
  Each project has a subdirectory in it.
  For example, `~/proj/xmenu/` for xmenu(1);
  `~/proj/c/` for notes on the C Programming Language; etc.

* `~/rules/`:
  Configuration files (aka dotfiles).
  For example, `~/rules/vimrc` (for vim);
  `~/rules/keybindings` (for sxhkd); etc.

* `~/skel/`:
  Skeleton files, that is, templates for different file formats.
  For example, `~/skel/Makefile` is a template for a Makefile;
  `~/skel/man.1` is a template for a section 1 man page; etc.

* `~/theme/`:
  Where I keep icons, cursors, fonts, etc.

* `~/tmp/`:
  Download directory and where I dump stuff.
  I try to keep it clean, but most of the time it is a mess.

* `~/usr/`:
  Program files (binaries, sources, manuals, etc).
  Each subdirectory contain files installed from a given source or using a given method.
  For example, `~/usr/local/` contains data for programs I install manually;
  `~/usr/python/` is for programs installed with pip(1);
  `~/usr/go/` is for programs installed with go(1); etc.
  Each subdirectory contains the directories bin/, src/, man/, and etc/
  (for binaries, source, manual and other files).
  For example, `~/usr/go/bin/lf` is the binary for lf installed by go(1);
  `~/usr/local/man/man1/xmenu.1` is the manual for xmenu(1) installed by its Makefile; etc.

* `~/var/`:
  Files that are not managed manually, but by applications.
  `~/var/trash/` is for trashed files managed by trash(1) and untrash(1);
  `~/var/mail/` is for email managed by mutt(1), mbsync(1) and others;
  `~/var/history/` is for command history from ksh(1), xprompt(1) and others;
  `~/var/cache/` is for cache used and generated by several programs.


## Shell Session

I use ksh(1) with emacs-like keybindings.  History is saved on
`~/var/history/ksh.hist`.

My PS1 prompt has the following structure:

* The prompt begins with a newline, for displaying vertical space
  between the output of the previous command and the current prompt.
  This makes easier the prompt visual identification.

* If the previous command exits with non-zero exit status, this exit
  status is printed, as bold and red, at the beginning of the prompt.

* The left prompt consists of a single ❯ character.  This character is
  white for normal users and red for the super user.  The left prompt
  is padded at the left with a single space.

* The right prompt is the cwd with the $HOME prefix replaced by a ~.
  The right prompt is padded at the right with a single space.

![Prompt changing through a shell session](https://user-images.githubusercontent.com/63266536/107708355-422f1c80-6cbb-11eb-9ed5-ab93aa8a82e2.gif)

I use few aliases, most of them to force human-readable output.  The
most useful alias is fuck, which rerun the previous command with
doas(1).

	alias fuck='doas $(fc -ln -1)'

## X Session

I use a blank desktop with no bars, docks or panels.

![A blank desktop](https://user-images.githubusercontent.com/63266536/107708689-d13c3480-6cbb-11eb-8c2e-c0250cc56d93.png)

The first thing done when I log into an X session is to load the
environment variables (by sourcing ~/.profile) and to load the X
resources with xrdb(1).  Key combinations are bound to commands by
sxhkd(1).  The cursor is made invisible after a brief period by
unclutter(1).  Music is managed by the mpd(1) music player daemon.

There are two ways to interact with the desktop: using the mouse
(which displays a pmenu(1)), or using the keyboard (which displays a
xprompt(1)).  Both ways output a command to a interpreter called
xinterp(1).  Responses are output in a notification window managed by
xnotify(1).  Each piece communicates with another by means of two named
pipes, `$XNOTIFY_FIFO` and `$XINTERP_FIFO`.

### Desktop Notification

The `$XNOTIFY_FIFO` environment variable contains the path to a named
pipe read by a program called xnotify(1).  This program reads lines
from its stdin and pops up a desktop notification for each read line.
This named pipe is written by several scripts.

![Writing to `$XNOTIFY_FIFO` pops a notification up](https://user-images.githubusercontent.com/63266536/107712835-fa5fc380-6cc1-11eb-9b6f-d1a429494485.gif)

First, a script called notify is run in the background and checks the
battery and computer temperature every minute.  If the battery is below
20% or the temperature is above 60°C, a line is written into
`$XNOTIFY_FIFO` and a notification is displayed for the user.

![Battery/temperature notification](https://user-images.githubusercontent.com/63266536/107713079-6a6e4980-6cc2-11eb-8d73-ba9aac3809fb.gif)

The xinterp(1) script also writes into `$XNOTIFY_FIFO` depending on the
instruction it reads (see next section below).  For example, when it
receives an instruction to change the music, a notification containing
the currently playing song is sent to `$XNOTIFY_FIFO`; when it receives
an instruction to change the current desktop, a notification listing
the desktops is sent to `$XNOTIFY_FIFO`.

![sending commands to xinterp(1)](https://user-images.githubusercontent.com/63266536/107713824-f5037880-6cc3-11eb-86ec-72af1f4c96da.gif)

### The Desktop Interpreter

The `$XINTERP_FIFO` environment variable contains the path to a named
pipe read by a script called xinterp(1).  This script reads
instructions from its stdin and run a given command depending on the
instruction read.  Those instructions are generated by pmenu(1) via
mouse interaction (see the Using the Mouse section below), and by
xprompt(1) via keyboard interaction (see the Using the Keyboard section
below).

For example, when selecting Firefox to be run using pmenu(1), the
command `run firefox` is sent to `$XINTERP_FIFO`.  The `run` command opens
a new instance of a program or focus an already existing one.

xinterp(1) understand several instructions, such as to launch an
application, open a manual page with zathura(1), change the current
desktop, manipulate the current window, etc.

### Using the mouse

When right clicking on the root window (ie', the desktop), a pie menu
is displayed by pmenu(1).

This pmenu(1) instance reads menu options from `~/var/cache/pmenu.cache`,
and outputs instructions to `$XINTERP_FIFO` to be interpreted by
xinterp(1).  The cache file is generated by xinterp(1) with the
following command:

	$ xinterp menu

With the pie menu, the user can launch applications, change the current
desktop, draw a terminal on the screen, change the song, take a
screenshot, and control the active window.

![Using pmenu(1) to draw a terminal and close it](https://user-images.githubusercontent.com/63266536/107714261-df428300-6cc4-11eb-9221-1acfe8a4f383.gif)

### Using the keyboard

When typing anything on the root window, a prompt is displayed by
xprompt(1).

This xprompt(1) instance reads options from `~/var/cache/xprompt.cache`,
and outputs instructions to `$XINTERP_FIFO` to be interpreted by
xinterp(1).  The cache file is generated by xinterp(1) with the
following command:

	$ xinterp prompt

With the prompt, the user can type any instruction that xinterp(1)
understands, for example, open man pages.

![opening a man page with xprompt](https://user-images.githubusercontent.com/63266536/107714641-8e7f5a00-6cc5-11eb-9720-de72889b860d.gif)

### The Window Manager

Windows are managed by the shod(1) window manager.  It is an hybrid
(tiling and floating) window manager that is controlled solely by
responding to client messages with EWMH hints and regular ICCCM events,
and by using a given key modifier with the mouse pointer.

Shod maintains one set of desktop for each monitor.  Each set of
desktop works like GNOME activities: The X session begins with a single
desktop; when a window is created, this desktop is populated, and a new
empty desktop is created.  When an empty desktop is populated, a new
empty one is created.

Windows begin floating on the desktop and are spawned in a proper empty
place.  The first window is spawned on the center of the monitor.  The
next windows are arranged in empty spaces on the monitor.

![automatic placement of floating windows](https://user-images.githubusercontent.com/63266536/107714967-27ae7080-6cc6-11eb-8ef8-3f98ef0989cf.gif)

When a window is maximized, it is tiled.  Tiled windows are organized
in columns; each tiled window ocupies a row in a column.  This
columnated behavior imitates the way acme(1) handle its columns and
frames.

![tiled windows](https://user-images.githubusercontent.com/63266536/107715163-92f84280-6cc6-11eb-8153-5b3c398ba156.png)
