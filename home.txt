                                 home

§ Description

This document describe my system and desktop, how I use it and how to
set it up.  This document is written in the incipit format, and can be
converted into troff with the incipit(1) script.  (Incipit is a markup
language I created).


§ Hardware

I use a secondhand Thinkpad T430 model 23501M2.

What I expected.
The following is the stock specification of this model, which comes
without the iconic biometric fingerprint reader.

{
	i5-3320M(2.6GHz), 8GB RAM, 320GB 7200rpm HD, 14in 1600x900 LCD,
	Intel HD Graphics, DVD Recordable, Intel 802.11agn wireless,
	WWAN upgradable, Bluetooth, 1Gb Ethernet, UltraNav, Secure Chip,
	Camera, 9c Li-Ion, Win7 Pro 64
}

What I bought.
However, being secondhand, the computer I bought was different from the
stock.  It came with a 465GB 7200rpm HD and a nonfunctional Bluetooth.

Modifications.
After receiving it, I made some modifications on the computer.
• I replaced the DVD optical drive with a Serial Ultrabay Enhanced HDD
  Adapter.  The adapter contains a TOSHIBA MQ01ABD0 500GB hard drive.
  See «https://thinkwiki.org/wiki/Ultrabay».
• I replaced the T430 chiclet-style keyboard with the T420 classic
  keyboard, using the method 2 (Sand down the nubs to fit in the T430
  palmrest) on «https://thinkwiki.org/wiki/Upgrading_T430_Keyboard».
  I have not flashed the BIOS to make the keyboard work from boot; but
  I use «xkbcomp(1)» to set the keymap on X11.
• I wrapped the T430 lid with a black faux leather vinyl adhesive.
  There are some videos on YouTube on how to wrap the laptop lid.

Future modifications.
There are other modifications I want to do on it.  For information on
T430 modding, see «https://medium.com/@n4ru/3dff3f6a8e2e».  I want to
do the following.
• Replace the CPU with a i7–3540M or a i7–3632QM.  Or with a i7–3840QM
  and a new heatsink.
• Replace the screen with a T440s/T440p 1080p FHD IPS screen.  See
  «https://thinkwiki.org/wiki/Replacing_T430_screen_with_a_better_one».
• Flash the BIOS.  See «https://github.com/n4ru/1vyrain».
• Replace the touchpad stick.
• Buy a slice battery.


§ System

I use OpenBSD -stable.  See «https://www.openbsd.org/faq» for more
information on the operating system and how to install it.

User.
After installation, I run «userinfo(8)» to make sure my user is in the
`wheel` user group and in the `staff` login class.  If it is not, I set
it up with «usermod(8)».

Doas.
Then, I create `/etc/doas.conf` to give administrator priviledges to
the `wheel` group.  The example file at `/etc/examples/doas.conf` is
reasonable, and can be used.  However, I like to not being asked for
a password again for some time after successfully authenticating.  I
also do not want the `$DISPLAY` environment variable to be retained.
{
	# echo "permit persist keepenv setenv { -DISPLAY } :wheel" >/etc/doas.conf
}

System resources limits.
The default system resources limits to the `staff` login class defined
at `/etc/login.conf` are reasonable.  But the `datasize-cur` option can
be increased a little bit, if necessary.
{
	# vi /etc/login.conf
}

Power management.
Then, I enable «apmd(8)» for power management in my laptop.  I use the
`-L` flag instead of the `-A` flag because it showed to heat less the
computer.  I use the `-z 10` flag to suspend the system when the battery
gets to 10% and no AC is connected.  I use the `-t 60` for «apmd(8)» to
poll the power state once per 60 seconds and log it via «syslog(3)».
{
	# rcctl enable apmd
	# rcctl set apmd flags -L -z 15 -t 60
	# rcctl start apmd
}

X Display Manager.
If «xenodm(1)» wasn't enabled during installation, it can be done so
later like any other system daemon.  I also edit xenodm's rc file
`/etc/X11/xenodm/Xsetup_0` to comment the line calling «xconsole(1)»,
disabling the xconsole window on the login screen.  I also add the line
`xset b off` to disable the system beep.
{
	# rcctl enable xenodm
	# rcctl start xenodm
	# cat <<EOF | ed -s /etc/X11/xenodm/Xsetup_0
	,s/^xconsole/#&/
	\$a
	xset b off
	.
	w
	EOF
}


§ Home directory

The contents of my `$HOME` directory are listed below.
Note that I do not use the XDG home structure.

• `~/.profile`:
  Shell script that sets the environment variables necessary
  to set up a user session.

• `~/.session`:
  Shell script called by ksh(1) to set up a shell session
  (prompt, aliases, etc).

• `~/.xsession`:
  Shell script called by xenodm(1) to set up a X session
  (notification system, window manager, etc).

• `~/files/`:
  Where I archive documents, media, and files for consumption.
  Each category of files has a subdirectory in it.
  For example, `~/files/doc/` for non-fiction books;
  `~/files/lit/` for fiction books;
  `~/files/meme/` is the meme folder;
  `~/files/mus/` is the music folder; etc.

• `~/proj/`:
  Where I put whatever I am working on (mostly college stuff, things I
  am learning, and programs I write).  Each project has a subdirectory
  in it.  For example, `~/proj/xmenu/` for xmenu(1); `~/proj/c/` for
  notes on the C Programming Language; etc.

• `~/rules/`:
  Configuration files (aka dotfiles).  For example, `~/rules/vimrc` (for
  vim); `~/rules/keybindings` (for sxhkd); etc.

• `~/skel/`:
  Skeleton files, that is, templates for different file formats.
  For example, `~/skel/Makefile` is a template for a Makefile;
  `~/skel/man.1` is a template for a section 1 man page; etc.

• `~/theme/`:
  Where I keep icons, cursors, fonts, etc.

• `~/tmp/`:
  Download directory and where I dump stuff.
  I try to keep it clean, but most of the time it is a mess.

• `~/usr/`:
  Program files (binaries, sources, manuals, etc).  Each subdirectory
  contain files installed from a given source or using a given method.
  For example, `~/usr/local/` contains data for programs I install
  manually; `~/usr/python/` is for programs installed with pip(1);
  `~/usr/go/` is for programs installed with go(1); etc.  Each
  subdirectory contains the directories `bin/`, `src/`, and `man/`
  (for binaries, source, manual and other files).  For example,
  `~/usr/go/bin/lf` is the binary for lf installed by go(1);
  `~/usr/local/man/man1/xmenu.1` is the manual for xmenu(1) installed by
  its Makefile; etc.

• `~/var/`:
  Files that are not managed manually, but by applications.
  `~/var/trash/` is for trashed files managed by trash(1) and untrash(1);
  `~/var/mail/` is for email managed by mutt(1), mbsync(1) and others;
  `~/var/history/` is for command history from ksh(1), xprompt(1) and others;
  `~/var/cache/` is for cache used and generated by several programs.


§ Profile

Environment variables are set and exported in the `~/.profile` file.
I prefer to use environment variables than configuration files to
configure my programs.

Installation prefixes.
The first part of this file sets the `$PATH` and `$MANPATH` environment
variables.  It loops through all the installation prefixes and verifies
whether there are binary directories or manpage directories in it, and
set those variables accordingly.  There are a lot of such prefixes in a
OpenBSD system, `/`, `/usr/`, `/usr/X11R6/` and `/usr/local/` are the
standard directories.  I also install some applications that creates
prefixes under `/usr/local`: `/usr/local/plan9`, `/usr/local/jdk-11`,
and `/usr/local/heirloom-doctools`.  In my `$HOME` there is also some
prefixes under `$HOME/usr`.  I then export those variables along with
`$HOME` and `$TERM`.

Local installation directories.
I install manually built programs at `~/usr/local/`.  I often use `make
-e install` to install stuff on the `$HOME/usr/local` prefix.  The `-e`
flag says that some variables (in this case, the prefix variables) must
be inherited from the environment.  Programs built by a language package
manager are installed at a directory under `~/usr/` specific to that
package manager.

Ksh terminal session.
My terminal session uses «ksh(1)» as shell.  This shell run commands
from the file pointed at by `$ENV` at the beginning of the session.
See «§Terminal Session» bellow.

Locale and timezone.
I live in Brazil, so I set `$LANG` to `pt_BR.UTF-8`.  Programs in base
ignore the `pt_BR` part, but programs in ports don't.  For character
encoding, I use `en_US.UTF-8` to force UTF-8 encoding.  For collation
order, I use `C` to force bytewise sorting rather than Unicode localized
collation.  I then set `$TZ` (timezone) to `America/Sao_Paulo`.

Directories.
The various directories and `$PATH`-like environment variables are set
in this block of lines.

Rule files.
My configuration files (or rules files, as I call them) live in the
`~/rules/` directory.  Some applications need a command line option to
read their rules files from that directory; others need a environment
variable.

My username.
I set `$IRCNAME` and other variables to `phillbush`.

Default programs.
Some environment variables define the default program to be used to open
or edit a file.

Theme.
Environment variables for themes, cursors, fonts, etc, come next.

Other stuff.
The remaining of the file contains variables specific to certain
programs or toolkits, like «firefox(1)», «nethack(6)», «xprompt(1)»,
«ls(1)», etc.

Umask.
At the end of `~/.profile`, I set the file mode creation mask.


§ Terminal Session

My terminal session is set up by commands run from the `~/.session`
script.

Set IFS for this file.
At the beginning of the file, I set the `$IFS` variable to newline,
after saving its old value in a dummy variable.  The IFS is necessary
for some commands in this file.  At the end of the file, the `$IFS` is
restored to its old value, and the dummy variable is unset.

Complete.
The `complete` function sets the `complete_CMDNAME` variables only if
a command named `CMDNAME` exists.

Directory stack.
To navigate between directories, I use something like bash's directory
stack (managed by the builtin commands `pushd` and `popd`).  The
function `dirs` list the directories in that stack.  The way I use the
stack differs from how pushd and popd work.

Change directory.
I override the `cd` builtin command with a function.  The path given to
the function can be a directory, or a regular file (in which case is
considered the directory in which it resides).  The function also sets
the completion for the `make` command to the Makefile in the current
directory.  If an argument is given, it is interpreted as follows.
• If the sole argument is a `+` the current directory is added to the
  beginning of the directory stack.
• If the first argument is a `+` followed by a list of paths, those
  paths are added to the directory stack.
• If the sole argument is `+N` (where N is a number), the N-th entry
  on the directory stack is moved to the beginning of the stack and it
  becomes the current directory.
• If the sole argument is a `-`, the previous current directory becomes
  the current directory.
• If the sole argument is `-N` (where N is a number), the N-th entry
  on the directory stack is removed from the stack.
• If the sole argument is composed with dots, a directory up in the
  hierarchy becames the current directory.  `cd ..` goes to the parent
  directory, `cd ...` goes to the parent's parent's directory, etc.
• If the sole argument is `..X` (where X is a word), go to the first
  directory up in the hierarchy containing word.  For example, if I am
  at `/home/phill/tmp/stuff/foo` and I enter the command `cd ..tmp`, I
  go to `/home/phill/tmp`.
• If the sole argument is a path, go to that path.

CDPATH.
The path supplied to the `cd` function is relative to the directories
listed (and separated with a colon) on the `$CDPATH` environment
variable.  I set it to the current directory (it must be the first
directory for a sane use of `cd`), my projects directory and my files
directory.

History.
History is saved on `~/var/history/ksh.hist`.

Options.
I use «ksh(1)» with emacs-like keybindings (for ^U and ^K, etc).
I also enable brace expansion.

Aliases.
I use few aliases.  There are aliases to file management, list files,
hexdump, commands with human-readable output.  The most useful alias
is `fuck`, which rerun the previous command with «doas(1)».

Completions.
I set up the completion lists for tab-completing the arguments of some
commands.  Those completion lists are set only once when the command
starts.  I also set the completion list for `make` at the end of the
`cd` command (see above).

Prompt.
My PS1 prompt has the following structure:
• First, the window title is set to the name of the tty device (on
  `/dev/`) and the pwd (with the `$HOME` prefix replaced with a `~`)
  separated by a colon and a space.
• The prompt begins with a newline, to display vertical space
  between the output of the previous command and the current prompt.
  This makes easier the prompt visual identification.
• The left prompt consists of a single `❯` character.  This character is
  white for normal users and red for the super user.  The left prompt is
  padded at the left with a single space.
• The right prompt is the pwd with the `$HOME` prefix replaced with a
  `~`.  The right prompt is padded at the right with a single space.

Print non-zero exit value.
If the previous command exits with non-zero exit status, this exit
status is printed, as bold and red, after the command exits.


§ X11 Session

I use a blank desktop with no bars, docks or panels.

The first thing done when I log into an X session is to load the
environment variables (by sourcing `~/.profile`) and to load the X
resources with «expenv(1)» and «xrdb(1)» (expenv is needed to expand
environment variables in the resources file).  Key combinations are
bound to commands by «sxhkd(1)».  The cursor is made invisible after
a brief period by «unclutter(1)».  Music is managed by the «mpd(1)»
music player daemon.

There are two ways to interact with the desktop: with the mouse (using
a «pmenu(1)»), or with the keyboard (using «xprompt(1)»).  Both ways
output a command to a interpreter called «xinterp(1)».  Responses are
output in a notification window managed by «xnotify(1)».  Each piece
communicates with another by means of two named pipes, `$XNOTIFY_FIFO`
and `$XINTERP_FIFO`.

§§ Desktop Notification

The `$XNOTIFY_FIFO` environment variable contains the path to a named
pipe read by a program called «xnotify(1)».  This program reads lines
from its stdin and pops up a desktop notification for each read line.
This named pipe is written by several scripts.

First, a script called notify is run in the background and checks the
battery and computer temperature every minute.  If the battery is below
20% or the temperature is above 60°C, a line is written into
`$XNOTIFY_FIFO` and a notification is displayed for the user.

The «xinterp(1)» script also writes into `$XNOTIFY_FIFO` depending on
the instruction it reads (see next section below).  For example, when
it receives an instruction to change the music, a notification
containing the currently playing song is sent to `$XNOTIFY_FIFO`; when
it receives an instruction to change the current desktop, a notification
listing the desktops is sent to `$XNOTIFY_FIFO`.

§§ The Desktop Interpreter

The `$XINTERP_FIFO` environment variable contains the path to a named
pipe read by a script called xinterp(1).  This script reads instructions
from its stdin and run a given command depending on the instruction.
Those instructions are generated by «pmenu(1)» via mouse interaction
(see the Using the Mouse section below) or by «xprompt(1)» via keyboard
interaction (see the Using the Keyboard section below).

For example, when selecting Firefox to be run using «pmenu(1)», the
command `run firefox` is sent to `$XINTERP_FIFO`.  The `run` command
opens a new instance of a program or focus an already existing one.

«xinterp(1)» understand several instructions, such as to launch an
application, open a manual page with «zathura(1)», change the current
desktop, manipulate the current window, etc.

§§ Using the mouse

When right clicking on the root window (ie', the desktop), a pie menu is
displayed by «pmenu(1)».

This «pmenu(1)» instance reads menu options from `~/var/cache/pmenu.cache`,
and outputs instructions to `$XINTERP_FIFO` to be interpreted by
«xinterp(1)».  The cache file is generated by «xinterp(1)» with the
following command:

{
	$ xinterp menu
}

With the pie menu, I can launch applications, change the current
desktop, draw a terminal on the screen, change the song, take a
screenshot, and control the active window.

§§ Using the keyboard

After typing Alt+space, a prompt is displayed by «xprompt(1)».
This «xprompt(1)» instance reads options from `~/var/cache/xprompt.cache`,
and outputs instructions to `$XINTERP_FIFO` to be interpreted by
«xinterp(1)».  The cache file is generated by xinterp(1) with the
following command:

{
	$ xinterp prompt
}

With the prompt, the user can type any instruction that «xinterp(1)»
understands, for example, open man pages.


§§ The Window Manager

Windows are managed by the «shod(1)» window manager.  It is an hybrid
(tiling and floating) tabbed window manager that is controlled solely by
responding to client messages with EWMH hints and regular ICCCM events,
and by using a given key modifier with the mouse pointer.

Shod maintains one set of desktop for each monitor.  Each set of desktop
works like GNOME activities: The X session begins with a single desktop;
when a window is created, this desktop is populated, and a new empty
desktop is created.  When an empty desktop is populated, a new empty one
is created.

Windows begin floating on the desktop and are spawned in a proper empty
place.  The first window is spawned on the center of the monitor.  The
next windows are arranged in empty spaces on the monitor.

When a window is maximized, it is tiled.  Tiled windows are organized in
columns; each tiled window ocupies a row in a column.  This columnated
behavior imitates the way acme(1) handle its columns and frames.


§ Theme

Themes are installed mostly at the `~/theme` directory.
I use the following themes.

• Tango color scheme:
  The 16 colors of my terminal emulator are those from the palette used
  by the Tango icon library.  This palette is described in the wikipedia
  article «https://en.wikipedia.org/wiki/Tango_Desktop_Project#Palette».

• Retrosmart icon theme:
  I use the Retrosmart icon theme, a set of icons mainly based on the
  Haiku OS look («https://github.com/mdomlop/retrosmart-icon-theme»).

• Retrosmart X11 cursor theme:
  I use the white version with alpha shading of the Retrosmart X11
  cursor theme («https://github.com/mdomlop/retrosmart-x11-cursors»).

• Input Mono Narrow font:
  I use the Input Mono Narrow font from the Input family of fonts
  («https://input.djr.com»).

• Motif-like window decoration:
  I use the default window decoration distributed with the shod window
  manager.

• Black background:
  I use a «xsetroot(1)» to set my background, with the options
  `-mod 3 3 -bg '#000000' -fg '#121212'`


